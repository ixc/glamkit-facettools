import sys
from django.utils.datastructures import SortedDict
from facettools.utils import get_verbose_name

class FacetLabel(object):
    def __init__(self, facet, name, is_all=False, is_selected=False):
        # the facet that I am a label of
        self.facet = facet
        # the string that is displayed
        self.name = name
        # the set of matching items (when no other facets are selected)
        # use `get_/set_items` to get and set.
        self._items = self.initialise_items()
        self.is_all = is_all
        self._matching_items = None
        self.is_selected = is_selected

    @property
    def items(self):
        return self._items

    def set_items(self, val, inhibit_save=False):
        self._items = val
        if not inhibit_save:
            self.save()

    def add_item(self, item, inhibit_save=False):
        # Assume we have a single item
        self._items.add(item)
        if not inhibit_save:
            self.save()

    def clear_items(self, inhibit_save=False):
        self.set_items(set(), inhibit_save)

    def matching_items(self):
        """
        The heart of the matter:

        Returns the items that are (or would be) matched if the item is
        selected, in combination with any other facet selections.

        This is tricky because if a sibling label is selected and will
        become unselected, or if there is a union relation between siblings,
        we need to take that effect into account.
        """

        if self._matching_items is None:
            if self.is_all:
                # then ignore whatever is selected
                result = self.facet.group.matching_items(ignore=[self.facet])
            elif self.facet.select_multiple and self.facet.intersect_if_multiple:
                # then simulate further intersection
                result = self.facet.group.matching_items() & self.items
            else:
                # then simulate intersection as though no other labels were
                # selected
                result = self.facet.group.matching_items(ignore=[self.facet]) & \
                       self.items

            self._matching_items = result
        return self._matching_items

    def invalidate(self):
        self._matching_items = None

    @property
    def count(self):
        return len(self.matching_items())

    @property
    def key(self):
        return "%s__%s" % (self.facet.key, self.name)

    def __eq__(self, other):
        if not isinstance(other, FacetLabel):
            return False
        return (self.key == other.key
            and self.facet == other.facet)

    def __unicode__(self):
        return self.name

    def __repr__(self):
        return "<%s: %s (%s)>" % (self.__class__.__name__, self.name,
                                  self.count)

    def initialise_items(self):
        # subclasses may retrieve a stored set for this label
        return set()

    def save(self):
        # a no-op, but used in subclasses that provide storage
        pass

class Facet(object):
    """
    A collection of FacetLabels, that is in turn grouped in a FacetGroup
    """
    _FacetLabelClass = FacetLabel

    def __init__(self,
                 verbose_name=None,
                 all_label="all",
                 cmp_func=None,
                 select_multiple=False,
                 intersect_if_multiple=False,
    ):
        self.group = None # a FacetGroup subclass. It will be populated by the
                            # metaclass
        self.name = None # this will be populated by the metaclass
        self._verbose_name = verbose_name # access with `verbose_name`
        self.all_label = all_label
        if cmp_func:
            self.cmp_func = cmp_func
        else:
            self.cmp_func = lambda a, b: cmp(a.name, b.name)
        self.select_multiple = select_multiple
        self.intersect_if_multiple = intersect_if_multiple
        # the collection of FacetLabelClass instances
        self.clear_items()

    @property
    def key(self):
        return "%s__%s" % (self.group.key(), self.name)

    @property
    def verbose_name(self):
        return self._verbose_name or self.name.replace("_", " ")

    def clear_items(self):
        """
        Clearing items on a facet means resetting labels.
        Subclasses that implement storage may want to purge the cache.
        """
        self._label_dict = {
            self.all_label: self._FacetLabelClass(facet=self,
                                            name=self.all_label, is_all=True,
                                            is_selected=True)
        } # dict of FacetLabel objects, for bookkeeping
        self.labels = None # a sorted list of FacetLabels objects for
        # displaying, generated by calling update()
        self._matching_items = None

    def index_item(self, item, inhibit_save=False):
        # call get_FOO_facet on the item
        attr_name = "get_%s_facet" % self.name
        attr = getattr(self.group, attr_name, None)

        if attr:
            facet_labels = attr(item)
        else:
            facet_labels = None

        if facet_labels is not None:
            self.index_labels(facet_labels, item, inhibit_save)

        # add every item to the 'all' facet
        self._label_dict[self.all_label].add_item(item)

    def unindex_item(self, item, inhibit_save=False):
        labels_to_remove = set()
        for facet_label in self._label_dict.values():
            facet_label.items.discard(item)
            if len(facet_label.items) == 0: #empty label! delete it.
                labels_to_remove.add(facet_label.name)
            if not inhibit_save:
                facet_label.save()

        for v in labels_to_remove:
            del self._label_dict[v]

    def index_labels(self, facet_labels, item, inhibit_save=False):
        for label in facet_labels:
            # initialise a FacetLabel if we have to
            if label not in self._label_dict:
                self._label_dict[label] = self._FacetLabelClass(facet=self,
                                                            name=label)

            self._label_dict[label].add_item(item)
        if not inhibit_save:
            self.save()

    def save(self):
        # save all my labels (it's a no-op, but subclasses may save to storage)
        for label in self._label_dict.values():
            label.save()

    def matching_items(self):
        if self._matching_items is None:
            for facet_label in self.selected():
                if self._matching_items is None:
                    self._matching_items = facet_label.items.copy()
                else:
                    if self.select_multiple and self.intersect_if_multiple:
                        # take intersection of selected facet_labels
                        self._matching_items &= facet_label.items
                    else:
                        # take union of selected facet_labels
                        self._matching_items |= facet_label.items

        return self._matching_items

    def invalidate(self):
        self._matching_items = None
        for facet_label in self._label_dict.values():
            facet_label.invalidate()

    def __unicode__(self):
        return self.name

    def __repr__(self):
        return "<%s: %s>" % (self.__class__.__name__, self.name)

    def sort(self, cmp_func=None):
        if cmp_func is None:
            cmp_func = self.cmp_func

        def _sort_func(a, b):
            if a.is_all:
                return -1
            if b.is_all:
                return 1

            return cmp_func(a, b)

        unsorted = self._label_dict.values()
        self.labels = sorted(unsorted, cmp=_sort_func)

    def select(self, *labels):
        """
        Mark label(s) of this facet as being selected.
        """

        # Can't select more than one label, unless select_multiple is true
        if len(labels) > 1:
            if not self.select_multiple:
                raise ValueError("%s does not allow more than one label to be"
                                 " selected" % self)
            if self.all_label in labels:
                raise ValueError("You cannot select 'all' at the same time as"
                                 " another facet")


        if not labels == [self.all_label]:
            self._label_dict[self.all_label].is_selected = False

        if not self.select_multiple or labels == [self.all_label]:
            # clear other selections
            for v in self._label_dict:
                self._label_dict[v].is_selected = False

        # make the selection
        for v in labels:
            self._label_dict[v].is_selected = True

    def unselect(self, *labels):
        """
        Mark label(s) of this facet as not being selected.
        """

        if labels == [self.all_label]:
            raise ValueError("You cannot unselect 'all'. Select another facet"
                             " instead.")

         # make the unselection
        for v in labels:
            self._label_dict[v].is_selected = False

        # if nothing is selected, select 'all'
        if len(self.selected()) == 0:
            self._label_dict[self.all_label].is_selected = True

    def clear_selection(self):
        for v in self._label_dict:
            self._label_dict[v].is_selected = False
        self._label_dict[self.all_label].is_selected = True

    def selected(self):
        return filter(lambda x: x.is_selected, self._label_dict.values())



class FacetGroupBase(type):
    """
    Metaclass for all FacetGroups
    """
    # FIXME: TODO:
    # We should deepcopy parent facets, because they'll be tied up in
    # different implementations and hence will have different metadata.
    def __new__(cls, name, bases, attrs):
        super_new = super(FacetGroupBase, cls).__new__
        parents = [b for b in bases if isinstance(b, FacetGroupBase)]
        if not parents:
            # If this isn't a subclass of FacetGroup,
            # don't do anything special.
            return super_new(cls, name, bases, attrs)

        # Figure out the app_label by looking one level up.
        # For 'shop.models', this would be 'shop'.
        module = attrs.pop('__module__')
        new_class = super_new(cls, name, bases, {'__module__': module})
        attr_meta = attrs.pop('Meta', None)
        if not attr_meta:
            meta = getattr(new_class, 'Meta', None)
        else:
            meta = attr_meta

        if getattr(meta, 'app_label', None) is None:
            model_module = sys.modules[new_class.__module__]
            app_label = model_module.__name__.split('.')[-2]
        else:
            app_label = meta.app_label
        new_class.add_to_class('app_label', app_label)

        # make the register of facets
        facets = SortedDict()

        # get facets from parents
        for base in parents:
            if isinstance(getattr(base, 'facets', None), SortedDict):
                facets.update(base.facets)

        # Add all attributes to the class.
        for obj_name, obj in attrs.items():
            new_class.add_to_class(obj_name, obj)
            if isinstance(obj, Facet):
                obj.name = obj_name
                obj.group = new_class
                facets[obj_name] = obj

        #sort facets according to field_order, if given.
        if getattr(meta, 'field_order', None) is not None:
            field_order = meta.field_order
            if field_order:
                new_class.add_to_class('field_order', field_order)
                try:
                    assert set(field_order) == set(facets.keys())
                except AssertionError:
                    raise ValueError("the field_order attribute of a FacetGroup "
                                     "does not contain all fields: %s vs %s") % \
                        (field_order, facets.keys())

                sorted_tuples = sorted(
                    facets.items(),
                    key=lambda x: field_order.index(x[0])
                )
                facets = SortedDict(sorted_tuples)
        new_class.add_to_class('facets', facets)

        return new_class

    def add_to_class(cls, name, value):
        if hasattr(value, 'contribute_to_class'):
            value.contribute_to_class(cls, name)
        else:
            setattr(cls, name, value)

class FacetGroup(object):
    """
    A Facetgroup is the whole set of facets on a collection that interact.
    """
    __metaclass__ = FacetGroupBase
    _matching_items = None

    # a `facets` SortedDict is injected by the metaclass,
    # which contains all of the facets defined in the subclass

    def __init__(self):
        raise TypeError("FacetGroup subclasses shouldn't be instantiated "
                        "(they are singleton-like).")

    @classmethod #shame it can't be a property
    def key(cls):
        return "%s__%s" % (cls.app_label, get_verbose_name(cls.__name__))

    @classmethod
    def rebuild_index(cls):
        """
        Bulk update to rebuild index
        1. erase old index
        2. iterate through unfiltered_collection
            add it to 'all' for each defined facet
            call get_FOO_facet for each defined facet
            update facet labels with the result
        3. save facet labels to the index
        4. update facets
        """
        cls.clear_items()
        for item in cls.unfiltered_collection():
            cls.index_item(item, inhibit_save=True)
        for facet in cls.facets.values():
            facet.save()
        cls.update()

    @classmethod
    def clear_items(cls):
        """
        Subclasses that implement storage may wish to purge the storage to
        avoid orphans.
        """
        for facet in cls.facets.values():
            facet.clear_items()

    @classmethod
    def index_item(cls, item, inhibit_save=False):
        for facet in cls.facets.values():
            facet.index_item(item, inhibit_save)

    @classmethod
    def unindex_item(cls, item, inhibit_save=False):
        for facet in cls.facets.values():
            facet.unindex_item(item, inhibit_save)

    @classmethod
    def matching_items(cls, ignore=[]):
        """
        Take the intersection of the items that match each facet.
        """
        if ignore == []:
            if cls._matching_items is not None:
                return cls._matching_items

        mi = None
        for facet in cls.facets.values():
            if facet not in ignore:
                if mi is None:
                    mi = facet.matching_items().copy()
                else:
                    mi &= facet.matching_items()

        if ignore == []:
            cls._matching_items = mi

        return mi

    @classmethod
    def invalidate(cls):
        cls._matching_items = None
        for facet in cls.facets.values():
            facet.invalidate()

    @classmethod
    def update(cls):
        """
        Invalidate the _matching_items cache
        Update the sort of facet labels to reflect the current selection.
        """
        cls.invalidate()
        for facet in cls.facets.values():
            facet.sort()

    @classmethod
    def clear_all(cls):
        """
        Unselect all facets
        """
        for facet in cls.facets.values():
            facet.clear_selection()

